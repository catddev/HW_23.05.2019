#pragma once
#include<exception>
#include<iostream>
#include<string>
using namespace std;



//Задание 3:

//Каждый блок catch предназначен для перехвата исключения определенного типа.
//До этого момента мы использовали исключения, которые представлялись базовыми типами.
//Давайте создадим пользовательский тип данных – класс CMyException,
//который будет содержать только одно поле данных – это строка(char *, char[], string ...), которое будет содержать информацию об ошибке.
//Создадим конструктор с параметром, который будет инициализировать это поле и необходимые методы.
//В блоке try сгенерируем исключение типа CMyException и перехопимо его в соответствующем блоке catch,
//выведем на экран сообщение об ошибке, использовав, например, метод класса имеет следующий прототип :
//char * MyException::ErrorMessage();

class MyException {
private:
	string s;
public:
	MyException() {
		s = "";
	}
	MyException(string s) {
		this->s = s;
	}

	const char* ErrorMessage() {
		return "THIS IS MY EXCEPTION";
	}
}my_ex;


//Задание 4:

//Для демонстрации раскрутки стека данных нам необходимо создать класс - демонстратор вызовов конструктора и деструктора(CTest),
//то есть поместим оператор вывода соответствующего сообщения на экран в указанные методы(конструктор и деструктор).
//Объявим и реализуем две функции, в которых создадим объект данного класса(CTest t;).
//Первая функция, после объявления объекта сразу вызовет функцию номер два,
//которая в свою очередь после объявления объекта сгенерирует исключение довідного типа.
//Вызов функции номер один разместим в блоке try
//и отловим сгенерированное второй функцией выключения в соответствующем блоке catch.

//Если все верно написано, то мы увидим на экране сообщение о вызове двух конструкторов
//и двух деструкторов объектов класса CTest,
//что будет свидетельствовать о том, что стек памяти, в котором содержались данные объекте корректно раскрутился

class CTest {
	string s;
public:
	CTest() {
		s = "";
		cout << "CONSTUCTOR" << endl;
	}
	~CTest() {
		cout << "DESTRUCTOR" << endl;
	}

};
void show2();
void show() {
	CTest t1;//при создании объекта срабатывает конструктор
	//cout << "THIS IS FIRST TEST" << endl;
	show2();//вызов второй функции
}
void show2() {
	CTest t2;//вызывается конструктор снова
	throw my_ex;
}
//по завршении срабатывают деструкторы для обоих объектов класса CTest